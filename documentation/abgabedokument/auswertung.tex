\chapter{Fazit der verwendeten Technologien}\label{fazit-tech}
\section{Scala}\label{auswertung:scala}
Subjektiv gesehen hat man stark das Gef\"uhl, dass Funktionale Sprachen, insbesondere Sprachen auf der Java- oder Dot-Net-Plattform in letzter Zeit das Interesse der Entwicklergemeinde auf sich gezogen haben. Auch der Tiobe Index \cite{tiobe} hat diese Tendenz in den letzten Monaten best\"atigt. Die erw\"ahnten Sprachen haben oft eine ``smartere'' Syntax (siehe Abschnitt ``\ref{imperativ-deklarativ} \titleref{imperativ-deklarativ}''), lassen sich im Grossen und Ganzen besser parallelisieren und k\"onnen in vielen Bereichen von bestehenden Bibliotheken und Frameworks ihrer bereits etablierten Plattformen profitieren. Die Zukunft geh\"ort diesen Sprachen, da Problemstellungen damit in wesentlich weniger LOC implementiert werden k\"onnen. Trotzdem behaupte ich, dass der Toolsupport noch lange nicht den Reifegrad wie bei anderen Sprachen erreicht hat und deshalb die Verbreitung der Sprache in der Industrie nur schleppend vonstatten geht. Auch die Nachfrage von Scala Entwicklern bei IT-Consulting unternehmen ist deshalb noch nicht so ausgepr\"agt. Trotzdem erweckt die Syntax und Semantik der Sprache bei vielen Begeisterung und ich m\"ochte in den folgenden Abschnitten nochmals kurz darau eingehen.

\subsection{Typisierung}
Typisierung ist einer der ersten Kriterien zur Klassifizierung von Sprachen, und bekanntlich scheiden sich hier auch bereits die Geister. In der Folge habe ich die am wohl verbreitetsten Argumente aufgelistet und m\"ochte anhand der statischen Sprache Scala zeigen, dass die meisten Argumente f\"alschlicherweise mit dem Thema Typisierung in Verbindung gebracht werden, obwohl sie eigentlich mit Typ Inferenz und Funktionen als ``first-class citizens'' zusammenh\"angen.

\begin{itemize}
\item Man sagt, dass statische Sprachen das DRY\footnote{Don't Repeat Yourself, ein Grundsatz f\"ur guten Code Smell}  verletzten. Als Beispiel wird genannt, dass man beispielsweise die Typen auf beiden Seiten des Gleichheitszeichen angeben m\"usse. Mit impliziter Typisierung sind bei Scala die Typen bereits bei Kompilierzeit bekannt.
\item Man sagt, dass statische Sprachen eine hohe Verbosit\"at haben. Dieser Punkt wird zum Beispiel im Zusammenhang mit anonymen Innerklassen genannt. Diese Aussagen kommen daher, dass typisierte Sprachen wie Java Funktionsobjekte und Closures bis jetzt leider noch nicht kennen.
\end{itemize}

Trotzdem, es gibt auch wirkliche Argumente die f\"ur die Programmierung mit dynamischen Sprachen sprechen. Unter anderem die geringere Kopplung zwischen Komponenten, die Verwendung von Interfaces kann per se reduziert werden und Klassen k\"onnen auch aus diesem Grund wesentlich einfacher getestet werden. 
  
\subsection{Syntax}
Bei der Einarbeitung in Scala f\"allt einem sofort folgendes auf:
\begin{itemize}
\item Scala ist statisch, stark typisiert, hat hervorragende Typ Inferenz
\item Scala wurde von vielen Sprachen beeinflusst: Java, ML, Haskell
\item Scala wurde von Personen entwickelt, die schon lange im Sprachdesign t\"atigt sind. Ich begr\"unde diese Aussage mit der auff\"allig klaren Konsistenz in allen Bereichen und insbesondere 
\begin{itemize}
\item hinsichtlich Operator Overloading, respektive alles ist eine Methode.
\item hinsichtlich der Verwendung von Collections wie List und Map. 
\end{itemize}
\item Scala beinhaltet grossartige Konzepte wie
\begin{itemize}
\item Pattern Matching.
\item Implizit Conversions.
\end{itemize}
\end{itemize}
\subsection{Tool Support}
Nebst der Tatsache, dass Scala Code um L\"angen mehr concise\footnote{englisches Wort f\"ur pr\"agnant, t\"ont einfach besser} ist als Java, wird man w\"ahrend der Entwicklung mit der Tatsache konfrontiert, dass das Tooling der Sprache hinterher hinkt: 
\begin{itemize}
\item der Scala Compiler ist aktuell noch nicht gen\"ugend schnell, es ist viel warten angesagt
\item die Code-Vervollst\"andigung erkennt nur ganz einfache Zusammenh\"ange.
\end{itemize}

\subsection{Verbreitung}
Trotz der Sch\"onheit und Kosistenz dieser Sprache, bin ich sehr gespannt, wie sie sich in der nahen Zukunft auch in der Industrie festsetzen wird. Ich bin der Meinung, dass die Verbreitung von Scala ohne ein Framework im Bereich des Internets sehr schwierig sein wird. Web Frameworks k\"onnen sich nur dann verbreiten, wenn durch eine augekl\"ugelte Erweiterbarkeit ein \"Okosystem rundherum entsteht. So dass es einerseits eine grosse Community gibt und Webseiten in kurzer Zeit und entsprechend kosteng\"unstig entstehen k\"onnen. Als Paradebeispiel in diesem Bereich sehe ich Rails aber auch Grails, Lift ist meines Erachtens aber noch zu wenig weit. Siehe Abschnitt ``\ref{auswertung:lift} \titleref{auswertung:lift}''

\section{Lift Framework}\label{auswertung:lift}
Mit Maven wurde ein ausgekl\"ugeltes Build-Tool gew\"ahlt, das die Basis f\"ur eine grosse Plattform werden k\"onnte. Trotzdem ist der Einstieg in Lift auch wegen der f\"ur viele Leute neuen Programmiersprache. Trotzdem unterscheiden sich die Probleme und Fragen zu Beginn nicht von denen bei anderen Frameworks:
\begin{itemize}
 \item Wie kann ich die Applikation innerhalb einer IDE bauen? 
 \item Welche IDE ist die richtige?
 \item Wie kann ich die Applikation starten und debuggen?
  \item Wie kann ich die Unit-Tests starten und debuggen?
 \item Wie komme ich an die Sourcen des Lift Frameworks\footnote{Die Source-Dateien von Lift sind noch nicht sehr lange im Maven Repository.}?
\end{itemize}

\subsection{Lift geht eigene Wege}
F\"ur die Implementation einer Applikation muss man Lift schon relativ gut kennen. Das Framework ist in vielen Bereichen sehr innovativ und geht entsprechend auch immer wieder andere Wege. Dies ist insofern verst\"andlich, da bereits durch die Auswahl der Programmiersprache eine F\"ulle anderer M\"oglichkeiten entstehen. Ich kritisiere trotzdem diesen Entscheid im Bereich des \textbf{Objekt-Relationalen-Mappings} - da wo es offensichtlich, trotz den vielen guten Ideen nicht gelang, eine ad\"aquate Alternative zu finden. Die JPA Anbindung h\"atte diese Ideen und Energie sicherlich gut gebrauchen k\"onnen. Auch im Bereich des \textbf{Dependency Injections} gibt es ein Paar Frameworks, die diese Funktionalit\"at besser und flexibler bereitstellen. Nebst Spring gibt es auch den Standard ``Context and Dependency Injection for Java'' , wo die Konfigurierbarkeit der Abh\"angigkeiten eine in meinen Augen noch nie da gewesene Flexibilit\"at  erm\"oglicht.

\subsection{Test Unterst\"utzung}
Die unterst\"utzung f\"ur \textbf{Unit-Tests} ist in erster Linie nicht eine Frage des Frameworks, sondern hat mit dem Aufbau und der Architektur der Applikation zu tun. Klassen lassen sich dann gut testen, wenn die Kopplung zum Umsystem gering ist und es wird entsprechend schwierig, wenn die Abh\"angigkeiten der UUT\footnote{Unit under Test}  schlecht abstrahiert und von aussen nicht gesetzt werden k\"onnen. Trotzdem gibt es ein paar interessante Punkte: 

\begin{itemize}
 \item Tests in Scala k\"onnen auf der Basis fast aller bekannter Frameworks erstellt werden: JUnit, TestNG, ScalaTest, ScalaSpecs. Ich habe mich f\"ur die ScalaSpecs entschieden, diese lassen es zu, menschenlesbare Spezifikationen zu schreiben. Mittlerweile finde ich den durch die Specs entstehenden erh\"ohten Aufwand nur in wenigen F\"allen ad\"aquat.
 \item Es gibt Mock-Klassen f\"ur HttpServletRequest, HttpServletResponse und HttpSession, die sich im Lift TestFramework befinden. F\"ur weitere Mocks siehe Package net.liftweb.mocks des Lift-Testkits.
\end{itemize}

Bei der Frage nach dem Framework-Support bei Integration Tests \footnote{dabei meine ich das Testen gesamter Gruppen, beinhaltet unter anderem auch die Anbindung an die Datenbank} trennt sich \"ublicherweise die Spreu vom Weizen. Die Unterst\"utzung durch Lift ist relativ bescheiden - Frameworks wie Grails und Rails bieten daf\"ur einen wesentlich gr\"osseren Funktionsumfang. 

\subsection{Fazit}
Um mich aufgrund der Kritik nicht falsch zu verstehen, ich werde Lift mit Sicherheit wieder einmal verwenden, allerdings w\"urde ich zum aktuellen Zeitpunkt aufgrund der in meinen Augen noch mangelnden Reife vom Gebrauch f\"ur eine Business-L\"osung abraten. Lift und Scala machen Spass, sind Hobby. Ich bin gespannt wie es weitergeht.


